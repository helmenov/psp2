
# あみだくじ

下図のようなあみだくじを考える．

```{.txt}
1 2 3 4 5
| | | | |
|-| | | |
| | |-| |
| |-| | |
| | | |-|
| | | |-|
|-| | | |
| |-| | |
| | |-| |
| | | | |
1 2 3 4 5
```

このあみだくじの結果は，

- 1 -> 2
- 2 -> 4
- 3 -> 3
- 4 -> 1
- 5 -> 5

となる．この結果を `dict` 型辞書で `kuji = {1:2, 2:4, 3:3, 4:1, 5:5}` と表す．

つまり，始点の縦線番号を player番号として， `dict` 型の `key` に player番号，それぞれの player が辿り着く 終点の縦線番号を `dict` 型の `value` とする．


```python
kuji = {1:2, 2:4, 3:3, 4:1, 5:5}
for i in range(5):
    l_start = i+1
    l_goal = kuji[l_start]
    print(f'{l_start} -> {l_goal}')
```

    1 -> 2
    2 -> 4
    3 -> 3
    4 -> 1
    5 -> 5


では，適当な結果を表した辞書（ `dict` 型）を引数として与えたときに，上の図のようなあみだくじの図を出力するようなプログラムを作ってみよう．

ただし，各行に配置できる横棒（交換）は一箇所のみとする．また棒は線を飛び越えることはできないとする．

ところで，上のあみだくじは，上の行から順番に棒を次のように配置している．各行の横に書いた `(i,j)` は，`i` 番線と `j` 番線を棒で繋ぐことを意味する．`(1,2)` と `(2,1)` とは同じ意味だが，ルールとして，$i < j$ とする．

```{.txt}
1 2 3 4 5
| | | | |
|-| | | | (1,2)
| | |-| | (3,4)
| |-| | | (2,3)
| | | |-| (4,5)
| | | |-| (4,5)
|-| | | | (1,2)
| |-| | | (2,3)
| | |-| | (3,4)
| | | | |
```


実は，同じ結果となるあみだくじは無数に存在する．

もっとも確実な構成法を考えてみよう．それは，

kuji = {1:2, 2:4, 3:3, 4:1, 5:5}のとき，

0. あみだくじを初期化する．つまり横棒は1行も存在しない．
1. `kuji[1] == 2`を確定させる．
  - つまり，player 1 を line 2 に移動させる棒を加える．`(1,2)`
  - 実は，この棒により，直前に line 2にいる player は直後 line 1 に移動する．直前に他の線にいる player はどこにも移動しない．
2. ステップ1の棒を置いた状態で，`kuji[2] == 4` を確定させるよう棒を加える．
  - player 2 はステップ1により line 1 に移っているので，つまりここで加える棒は，直前に line 1 にいるplayer を line 4 に連れて行く棒である．一挙に連れていけないので，`(1,2), (2,3), (3,4)`と3行の棒を加える
  - 結果，直前で line 2 にいる player は line 1に, line 3はline2に，line4 は line 3に移る．これをもと居た線に戻す横棒を加えるが，line4→3である `(4,3)` は上記の`(3,4)`をキャンセルしてしまうので，それ以外の
    `(3,2),(2,1)`を加える．つまり`(2,3),(1,2)`を加える
3. ステップ2まの棒をおいた状態で，`kuji[3] == 3` を確定させるよう棒を加える．
  - player 3は，ステップ2までの棒をおいた状態でも未だ line 3におり，行き先も line 3であるから，ここで加えるべき棒はない．
4. ステップ3までの棒を置いた状態で，`kuji[4] == 1` を確定させるよう棒を加える．
  - player 4 は，ステップ3までの状態で，line 3に移動している．よって，line 3 から line 1 まで移動させる．`(3,2), (2,1)`を加えればよい．つまり`(2,3),(1,2)`を加える．
  - 結果，line 2はline3に，line 1はline2に移動してしまう．したがってこれらを元居た線に戻す．ただし，`(2,1)`は上記の`(1,2)`をキャンセルしてしまうので，`(3,2)`だけ加える．すなわち`(2,3)`を加える．
5. 以下同様の手順で完成させる．

という方法である．

やってみよう．

- [step1] まず，コマ1の行き先は，場所2であるから，

```
L1 (1,2)
```

である．これで場所1にいるplayerは場所2に移り，場所2にいるコマは場所1に移る．

- [step2] 次に2の行き先を4に確定させる．

L1でコマ2は場所1に移ってしまっているため，1<->4を複数の横棒で構成する．したがって，

```
L2 (1,2)
L3 (2,3)
L4 (3,4)
L5 (2,3)
L6 (1,2)
```

が加わる．

- [step3] さきほどのコマ1はL2の直前で場所2に移っており，L2〜L6の間にL2で場所1に戻るが，L6で場所2にまた移る．つまり補正はいらない．

これで1と2の行き先が確定したので，

- [step4] 次に3の行き先を3に確定させる．L1〜L6の間に，コマ3はL3で場所2に，さらにL5で場所3に戻る．したがって，場所3にいるコマを，場所3に移す．すなわち横棒の追加はない．

[step5] コマ1,2の行き先も変わっていないので，補正はいらない．

[step6] 次にコマ4を場所1に移し，場所1にあるコマを場所4に移す．L1〜L6までで，コマ4は，L4の操作で3に移り．さらにL5で2に移り，L6で1に移っているため，
あらたに横棒を加える必要がない．

[step7] 同様の手順で，5->5に確定させるが，L1からL6で5の縦棒に関わることがないため，何も行を加えない．

結果，

```
L1 (1,2)
L2 (1,2)
L3 (2,3)
L4 (3,4)
L5 (2,3)
L6 (1,2)
```

すなわち

```
1 2 3 4 5
| | | | |
|-| | | | (1,2)
|-| | | | (1,2)
| |-| | | (2,3)
| | |-| | (3,4)
| |-| | | (2,3)
|-| | | | (1,2)
| | | | |
```


ちなみに，

```
L1(1,2)
L2(1,2)
```

というように2つの縦棒の間のみで連続して横棒を配置している操作は，結局何もしていないのと同じなので，省くことができる．

```
1 2 3 4 5
| | | | |
| |-| | | (2,3)
| | |-| | (3,4)
| |-| | | (2,3)
|-| | | | (1,2)
| | | | |
```

最初に示したあみだくじにおいても

```
1 2 3 4 5
| | | | |
|-| | | | (1,2)
| | |-| | (3,4)
| |-| | | (2,3)
|-| | | | (1,2)
| |-| | | (2,3)
| | |-| | (3,4)
| | | | |
```

# k04 (1)

この過程をコーディングし，モジュール`amida.py`を作成し，次の`k04_1.py`を`python k04_1.py`で動かしたときにあみだくじの図が出力されるようにせよ．あみだくじのエントリの数（縦棒の本数）は`len(dict)`によって決定される．


```python
# k04_1.py

import amida

kuji = {1:4, 2:3, 3:1, 4:5, 5:2} # {ID:goal}形式のdict
L = [] # 横棒のリスト

for ID, goal in kuji.items():
    now = amida.getstate(L, ID) # 既にある横棒Lの操作後における，IDの現在地を返す

    if now == goal: # IDの現在地がすでにgoalにあるならこのifブロックより後の処理を飛ばして次の繰り返しへ
        continue

    lines = amida.genroutes(now,goal) # IDが現在地nowからgoalに移るまでの横棒リストを返す．

    L.extend(lines) # 既存のリストの後ろにlineを加える

amida.plot(L,kuji) # あみだくじを描画する


```


```python
# amida.py

def getstate(L, ID):
    """
    始点IDが，横線リストLのあとにどこに移動するかを返す
    """
    state = ID
    for l,r in L:
        if state == l:
            state = r
        elif state == r:
            state = l
    now = state
    return now


def genroutes(now,goal):
    """ nowとgoalを交換するための横棒リストを作る

    Args:
        now (int): 
        goal (int): 

    ex) now,goal = 1,4 なら
    [[1,2],
     [2,3],
     [3,4],
     [2,3],
     [1,2]]
    というリストを作って返す．
    """

    # write codes in here

    return lines


def plot(L,kuji):
    """
    横線リストLに基づいて，あみだくじを描画する．縦線の数はlen(kuji)
    """
    for i in range(len(kuji)):
        print(f'{i+1} ',end='')
    print('')
    for i in range(len(kuji)):
        print('| ',end='')
    print('')

    for line in L:               # 横棒リストを読みながら，あみだくじの行を描画
        for i in range(1,len(kuji)):
            if i == line[0]:
                print('|-',end='')
            else:
                print('| ',end='')
        print(f'| {line}')

    for i in range(len(kuji)):
        print('| ',end='')
    print('\n')


def reduct(L):
    """
    L に2回連続する同一横線が無くなるよう修正する
    """
    # write codes in here

    return L


def insert(exchange, slice, before):
    """before(List of List)のslice番号に，exchange(List)を挿入

    """
    # write codes in here

    return L


def fix(L,kuji):
    """
    kuji を満たすように L に横線を追加する
    """
    return L

```

## k04 (2)

連続して同じ横棒が続くとき，それを省略する関数をモジュールamida.pyに加えよ．結果得られるリストには，一切無駄が無いようにせよ．
- 一箇所省略すると，その前後が連結される．場合によってはその連結が同一の横棒の連続になっていることもある．したがって再度省略作業を行う必要がある．
- このような省略作業のループは，省略作業の前後でリストの長さ（あみだくじの長さ）が変わらなかった場合に脱出するようにすればよい．

例えば 
`L = [(1,2),(2,3),(3,4),(2,3),(2,3),(3,4),(3,4),(3,4),(2,3)]`
というあみだくじは，
`L = [(1,2)]`
となるはずである．確かめてみよ．



```python
# k04_2_1.py

import amida

kuji = {1:4, 2:3, 3:1, 4:5, 5:2}
L1 = [(1,2),(2,3),(3,4),(2,3),(2,3),(3,4),(3,4),(3,4),(2,3)]
L2 = amida.reduct(L1)

print('[before]')
amida.plot(L1,kuji)
print('[after]')
amida.plot(L2,kuji)

```


```python
# k04_2_2.py

import amida

kuji = {1:4, 2:3, 3:1, 4:5, 5:2} # {ID:goal}形式のdict
L = [] # 横棒のリスト

for ID, goal in kuji.items():
    now = amida.getstate(L, ID) # 既にある横棒Lの操作後における，IDの現在地を返す

    if now == goal: # IDの現在地がすでにgoalにあるならこのifブロックより後の処理を飛ばして次の繰り返しへ
        continue

    lines = amida.genroutes(now,goal) # IDが現在地nowからgoalに移るまでの横棒リストを返す．

    L.extend(lines) # 既存のリストの後ろにlineを加える

L = amida.reduct(L) # Lの中で連続する同じ横棒を省略する

amida.plot(L,kuji) # あみだくじを描画する

```

# k04 (3)

既存の横棒リストの途中に適当な横棒が挿入されたとき，最終的に結果が変わらないようにするため，既存のリストに新たに横棒を加えよ．

例えば，上記の例では，{1:4, 2:3, 3:1, 4:5, 5:2}となるあみだくじは，

```
1 2 3 4 5 
| | | | | 
|-| | | | L1: [1, 2] 
| |-| | | L2: [2, 3]
| | |-| | L3: [3, 4]
| |-| | | L4: [2, 3]
|-| | | | L5: [1, 2]
| |-| | | L6: [2, 3]
|-| | | | L7: [1, 2]
| |-| | | L8: [2, 3]
| | |-| | L9: [3, 4]
| | | |-| L10:[4, 5]
| | |-| | L11:[3, 4]
| |-| | | L12:[2, 3]
| | | | | 
```

となるが，ここでL1とL2の間に`[1,2]`を挿入すると，最終的な結果が変わってしまう．

```
1 2 3 4 5 
| | | | | 
|-| | | | L1: [1, 2] 
|_| | | |            <---[1, 2]       
| |-| | | L2: [2, 3]
| | |-| | L3: [3, 4]
| |-| | | L4: [2, 3]
|-| | | | L5: [1, 2]
| |-| | | L6: [2, 3]
|-| | | | L7: [1, 2]
| |-| | | L8: [2, 3]
| | |-| | L9: [3, 4]
| | | |-| L10:[4, 5]
| | |-| | L11:[3, 4]
| |-| | | L12:[2, 3]
| | | | | 

```

そこで，結果を変えないように，L4のあとに新たに必要なだけ横棒を加えることになる．

```
1 2 3 4 5 
| | | | | 
|-| | | | L1: [1, 2] 
|_| | | |            <---[1, 2]       
| |-| | | L2: [2, 3]
| | |-| | L3: [3, 4]
| |-| | | L4: [2, 3]
|-| | | | L5: [1, 2]
| |-| | | L6: [2, 3]
|-| | | | L7: [1, 2]
| |-| | | L8: [2, 3]
| | |-| | L9: [3, 4]
| | | |-| L10:[4, 5]
| | |-| | L11:[3, 4]
| |-| | | L12:[2, 3]
| | |-| |            <---[3, 4] *
| | | | | 
```

モジュール`amida.py`に　insert関数，fix関数を加えて，`python k04_3.py`の結果が正しく表示されるようにせよ．

挿入する横棒，挿入するスライスなどを変えても正しく動くことを確かめること．


```python
# k04_3.py

import amida

kuji = {1:4, 2:3, 3:1, 4:5, 5:2} # {ID:goal}形式のdict
before = [[1, 2], [2, 3], [3, 4], [2, 3], [1, 2], [2, 3], [1, 2], [2, 3], [3, 4], [4, 5], [3, 4], [2, 3]] # 既存の横棒のリスト

amida.plot(before,kuji) # あみだくじを描画する

L = amida.insert([1,2], 1, before) # [1,2]をリストprevのスライス1に挿入する

amida.plot(L,kuji) # 改変されたあみだくじを描画する

after = amida.fix(L, kuji) # Lの後ろに補正を加える．

after = amida.reduct(after)

amida.plot(after,kuji) # あみだくじを再描画
```

# 以上，k04 について，提出物は，

- amida.py
- (1),(2-1),(2-2),(3)の実行結果スクショ（表示されるあみだくじが全て見渡せるもの）


